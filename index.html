<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Invitación a la Cita</title>
    <!-- Icono de la página web (favicon) -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>❤️</text></svg>">
    <!-- Incluye Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Estilos personalizados para el fondo y las animaciones */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #fce7f3; /* Rosa claro para un toque romántico */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh; /* Asegura que el cuerpo ocupe al menos el 100% del alto del viewport */
            margin: 0;
            overflow: hidden; /* Para que los corazones no generen scroll */
        }
        .card-container {
            background-color: #fff;
            border-radius: 20px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            padding: 30px;
            width: 90%; /* Ocupa el 90% del ancho disponible */
            max-width: 500px; /* Máximo de 500px para pantallas grandes */
            text-align: center;
            position: relative;
            overflow: hidden; /* Para contener los corazones dentro de la tarjeta */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            min-height: 600px; /* Altura mínima para asegurar que el Tetris quepa cómodamente */
        }
        .page {
            display: none;
            flex-grow: 1;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }
        .page.active {
            display: flex;
        }
        .navigation-buttons {
            display: flex;
            width: 100%;
            margin-top: 20px;
            /* La justificación se controlará dinámicamente con JavaScript */
        }
        .btn {
            background-color: #f472b6; /* Rosa más oscuro */
            color: white;
            padding: 12px 25px;
            border-radius: 15px;
            font-weight: bold;
            transition: background-color 0.3s ease, transform 0.2s ease;
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.15);
            cursor: pointer;
        }
        .btn:hover {
            background-color: #ec4899; /* Rosa aún más oscuro al pasar el ratón */
            transform: translateY(-2px);
        }
        .heart-icon {
            color: #ef4444; /* Rojo vibrante */
            font-size: 6rem;
            margin-bottom: 20px;
            animation: pulse 1.5s infinite alternate;
        }

        /* Animación de pulso para el corazón */
        @keyframes pulse {
            from {
                transform: scale(1);
            }
            to {
                transform: scale(1.1);
            }
        }

        /* Estilos para el juego de Tetris */
        canvas {
            border: 2px solid #f472b6;
            background-color: #1a202c; /* Fondo oscuro para el juego */
            display: block;
            margin: 20px auto;
            border-radius: 10px;
        }

        /* Estilos para las opciones de cena */
        .dinner-option {
            background-color: #ffe4e6; /* Rosa muy claro */
            padding: 15px 20px;
            border-radius: 15px;
            margin-bottom: 15px;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            color: #333;
        }
        .dinner-option:hover {
            background-color: #fbcfe8; /* Rosa un poco más oscuro */
            transform: translateY(-2px);
        }
        .dinner-option a {
            text-decoration: none;
            color: inherit;
            display: block;
            width: 100%;
        }

        /* Animación de explosión para el emoji de corazón */
        .exploding-emoji {
            position: absolute;
            font-size: 0; /* Se ajustará dinámicamente en JS */
            opacity: 0;
            animation: explodeEmoji 1.5s forwards; /* Aumenta la duración para un efecto más suave */
            pointer-events: none;
            z-index: 1000;
            line-height: 1; /* Eliminar espacio extra alrededor del emoji */
        }

        @keyframes explodeEmoji {
            0% {
                transform: translate(-50%, -50%) scale(0) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translate(var(--end-x), var(--end-y)) scale(2) rotate(720deg); /* Movimiento y rotación aleatorios */
                opacity: 0;
            }
        }
    </style>
</head>
<body>
    <div class="card-container">
        <!-- Página 1: Ubicación -->
        <div id="page1" class="page active">
            <h2 class="text-4xl font-bold text-pink-600 mb-6">Demi, te invito a una cita</h2>
            <div class="text-7xl mb-8 heart-icon">❤️</div>
            <p class="text-xl text-gray-700 mb-4">NUESTRA CITA ES EN:</p>
            <p class="text-2xl font-semibold text-pink-500 mb-6">
                <a href="https://www.google.com/maps/place/Feria+Itinerante+de+Abastecimiento+Barrial+-+FIAB+12/@-34.5926959,-58.4200738,17z/data=!3m1!4b1!4m6!3m5!1s0x95bccb8ff34c075b:0x41eaa5c1624f506!8m2!3d-34.5926959!4d-58.4200738!16s%2Fg%2F11rw7nwlk4?entry=ttu&g_ep=EgoyMDI1MDcyMy4wIKXMDSoASAFQAw%3D%3D" target="_blank" class="text-pink-500 hover:underline">
                    📍 Palermo, Buenos Aires
                </a>
            </p>
            <p class="text-lg text-gray-600">¡Te espero con ansias!</p>
        </div>

        <!-- Página 2: Tetris -->
        <div id="page2" class="page">
            <h2 class="text-3xl font-bold text-pink-600 mb-6">Un Pequeño Juego para Ti</h2>
            <p class="text-lg text-gray-700 mb-4">¡Relájate y juega un poco de Tetris!</p>
            <canvas id="tetrisCanvas" width="240" height="400"></canvas>
        </div>

        <!-- Página 3: Encuesta de Cena -->
        <div id="page3" class="page">
            <h2 class="text-3xl font-bold text-pink-600 mb-6">¿Qué te apetece cenar?</h2>
            <p class="text-lg text-gray-700 mb-6">¡Elige tu opción favorita para nuestra cena!</p>
            <div class="w-full">
                <div class="dinner-option">
                    <a href="https://maps.app.goo.gl/GcUSVYt4NnmCqyrF7?g_st=ipc" target="_blank">
                        🍕 Opción Focaccia
                    </a>
                </div>
                <div class="dinner-option">
                    <a href="https://maps.app.goo.gl/7hVHstpRWk12gVep7?g_st=ipc" target="_blank">
                        🍝 Opción Pasta
                    </a>
                </div>
                <div class="dinner-option">
                    <a href="https://maps.app.goo.gl/unbVQMkkDLgJs9b78?g_st=ipc" target="_blank">
                        🍔 Opción Bodegón
                    </a>
                </div>
            </div>
        </div>

        <!-- Página 4: Gracias y Regalo -->
        <div id="page4" class="page">
            <h2 class="text-4xl font-bold text-pink-600 mb-6">¡Gracias por venir!</h2>
            <p class="text-xl text-gray-700 mb-8">¡Espero que disfrutes de este pequeño detalle!</p>
            <button id="giftButton" class="btn">Apreta acá para tu regalo</button>
        </div>

        <!-- Controles de navegación -->
        <div class="navigation-buttons">
            <button id="prevBtn" class="btn" style="display: none;">Anterior</button>
            <button id="nextBtn" class="btn">Siguiente</button>
        </div>
    </div>

    <script>
        // JavaScript para la navegación entre páginas
        let currentPage = 1;
        const totalPages = 4;
        const pages = document.querySelectorAll('.page');
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');
        const giftButton = document.getElementById('giftButton');
        const cardContainer = document.querySelector('.card-container');
        const navButtonsContainer = document.querySelector('.navigation-buttons');

        function showPage(pageNumber) {
            pages.forEach((page, index) => {
                if (index + 1 === pageNumber) {
                    page.classList.add('active');
                } else {
                    page.classList.remove('active');
                }
            });

            // Actualizar visibilidad de los botones de navegación
            prevBtn.style.display = pageNumber === 1 ? 'none' : 'block';
            nextBtn.style.display = pageNumber === totalPages ? 'none' : 'block';

            // Ajustar la justificación de los botones
            if (pageNumber === 1 && nextBtn.style.display === 'block') {
                // Si es la primera página y solo se muestra 'Siguiente', alinear a la derecha
                navButtonsContainer.style.justifyContent = 'flex-end';
            } else if (pageNumber === totalPages && prevBtn.style.display === 'block') {
                // Si es la última página y solo se muestra 'Anterior', alinear a la derecha
                navButtonsContainer.style.justifyContent = 'flex-end';
            } else {
                // En cualquier otro caso (páginas intermedias o si ambos están visibles), usar space-between
                navButtonsContainer.style.justifyContent = 'space-between';
            }
        }

        nextBtn.addEventListener('click', () => {
            if (currentPage < totalPages) {
                currentPage++;
                showPage(currentPage);
            }
        });

        prevBtn.addEventListener('click', () => {
            if (currentPage > 1) {
                currentPage--;
                showPage(currentPage);
            }
        });

        // JavaScript para el juego de Tetris (simplificado)
        const canvas = document.getElementById('tetrisCanvas');
        const ctx = canvas.getContext('2d');
        const COLS = 10;
        const ROWS = 20;
        const BLOCK_SIZE = 20;
        let board = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
        let score = 0;
        let gameOver = false;

        const PIECES = [
            [[1, 1, 1, 1]], // I
            [[1, 1], [1, 1]], // O
            [[0, 1, 0], [1, 1, 1]], // T
            [[1, 1, 0], [0, 1, 1]], // S
            [[0, 1, 1], [1, 1, 0]], // Z
            [[1, 0, 0], [1, 1, 1]], // L
            [[0, 0, 1], [1, 1, 1]]  // J
        ];

        const COLORS = [
            '#000', // No block
            'cyan', 'yellow', 'purple', 'green', 'red', 'orange', 'blue'
        ];

        let currentPiece;
        let currentX;
        let currentY;

        function newPiece() {
            const rand = Math.floor(Math.random() * PIECES.length);
            currentPiece = PIECES[rand];
            currentX = Math.floor(COLS / 2) - Math.floor(currentPiece[0].length / 2);
            currentY = 0;

            if (!isValidMove(0, 0, currentPiece)) {
                gameOver = true;
                // Reemplazado alert() por un mensaje en consola
                console.log('Game Over! Score: ' + score);
            }
        }

        function drawBlock(x, y, color) {
            ctx.fillStyle = color;
            ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            ctx.strokeStyle = '#333';
            ctx.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
        }

        function drawBoard() {
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    drawBlock(c, r, COLORS[board[r][c]]);
                }
            }
        }

        function drawPiece() {
            for (let r = 0; r < currentPiece.length; r++) {
                for (let c = 0; c < currentPiece[r].length; c++) {
                    if (currentPiece[r][c]) {
                        drawBlock(currentX + c, currentY + r, COLORS[PIECES.indexOf(currentPiece) + 1]);
                    }
                }
            }
        }

        function isValidMove(offsetX, offsetY, newPiece) {
            for (let r = 0; r < newPiece.length; r++) {
                for (let c = 0; c < newPiece[r].length; c++) {
                    if (newPiece[r][c]) {
                        const newX = currentX + c + offsetX;
                        const newY = currentY + r + offsetY;

                        if (newX < 0 || newX >= COLS || newY >= ROWS || (newY >= 0 && board[newY][newX])) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }

        function mergePiece() {
            for (let r = 0; r < currentPiece.length; r++) {
                for (let c = 0; c < currentPiece[r].length; c++) {
                    if (currentPiece[r][c]) {
                        board[currentY + r][currentX + c] = PIECES.indexOf(currentPiece) + 1;
                    }
                }
            }
        }

        function clearLines() {
            let linesCleared = 0;
            for (let r = ROWS - 1; r >= 0; r--) {
                if (board[r].every(cell => cell !== 0)) {
                    linesCleared++;
                    for (let row = r; row > 0; row--) {
                        board[row] = [...board[row - 1]];
                    }
                    board[0].fill(0);
                    r++; // Check the new line at this row index
                }
            }
            score += linesCleared * 100; // Simple scoring
        }

        function gameLoop() {
            if (gameOver) return;

            if (isValidMove(0, 1, currentPiece)) {
                currentY++;
            } else {
                mergePiece();
                clearLines();
                newPiece();
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawBoard();
            drawPiece();
            setTimeout(gameLoop, 500); // Piece drops every 500ms
        }

        // Initialize Tetris only when page 2 is active
        let tetrisInitialized = false;
        function initTetris() {
            if (!tetrisInitialized) {
                newPiece();
                gameLoop();
                tetrisInitialized = true;
            }
        }

        // Event listener for page changes to start Tetris
        nextBtn.addEventListener('click', () => {
            if (currentPage === 2 && !tetrisInitialized) {
                initTetris();
            }
        });

        // Simple keyboard controls for Tetris (for desktop)
        document.addEventListener('keydown', e => {
            if (currentPage === 2 && !gameOver) {
                if (e.key === 'ArrowLeft' && isValidMove(-1, 0, currentPiece)) {
                    currentX--;
                } else if (e.key === 'ArrowRight' && isValidMove(1, 0, currentPiece)) {
                    currentX++;
                } else if (e.key === 'ArrowDown' && isValidMove(0, 1, currentPiece)) {
                    currentY++;
                } else if (e.key === 'ArrowUp') { // Rotate
                    const rotatedPiece = currentPiece[0].map((_, index) =>
                        currentPiece.map(row => row[index]).reverse()
                    );
                    if (isValidMove(0, 0, rotatedPiece)) {
                        currentPiece = rotatedPiece;
                    }
                }
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawBoard();
                drawPiece();
            }
        });

        // JavaScript para la explosión del emoji de corazón
        giftButton.addEventListener('click', () => {
            const numExplosions = 50; // Cantidad de emojis a explotar
            const buttonRect = giftButton.getBoundingClientRect();
            // Posición del centro del botón respecto al contenedor de la tarjeta
            const buttonCenterX = buttonRect.left + buttonRect.width / 2 - cardContainer.getBoundingClientRect().left;
            const buttonCenterY = buttonRect.top + buttonRect.height / 2 - cardContainer.getBoundingClientRect().top;

            for (let i = 0; i < numExplosions; i++) {
                const emojiElement = document.createElement('div');
                emojiElement.classList.add('exploding-emoji');
                emojiElement.textContent = '❤️'; // El emoji de corazón

                // Posicionar el emoji inicialmente en el centro del botón (relativo al card-container)
                emojiElement.style.left = `${buttonCenterX}px`;
                emojiElement.style.top = `${buttonCenterY}px`;

                // Tamaños aleatorios para los emojis que explotan
                const size = Math.random() * 40 + 20; // Tamaño entre 20px y 60px
                emojiElement.style.fontSize = `${size}px`; // Usar font-size para el emoji

                // Definir el punto final aleatorio para la animación
                const endX = Math.random() * cardContainer.offsetWidth * 1.5 - (cardContainer.offsetWidth * 0.25);
                const endY = Math.random() * cardContainer.offsetHeight * 1.5 - (cardContainer.offsetHeight * 0.25);
                emojiElement.style.setProperty('--end-x', `${endX}px`);
                emojiElement.style.setProperty('--end-y', `${endY}px`);

                emojiElement.style.animationDuration = `${Math.random() * 1.5 + 1}s`; // Duración aleatoria
                emojiElement.style.animationDelay = `${Math.random() * 0.5}s`; // Retraso aleatorio

                cardContainer.appendChild(emojiElement);

                // Eliminar el emoji después de la animación
                emojiElement.addEventListener('animationend', () => {
                    emojiElement.remove();
                });
            }
        });

        // Mostrar la primera página al cargar
        showPage(currentPage);
    </script>
</body>
</html>
